<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat</title>
  <style>
    :root{--bg:#0f1720;--card:#111827;--muted:#9ca3af;--accent:#60a5fa;--me:#10b981}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#071025 0%, #0b1220 100%);color:#e6eef8;display:flex;align-items:center;justify-content:center;padding:18px}
    .app{width:100%;max-width:820px;height:90vh;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.7);display:flex;flex-direction:column;overflow:hidden}
    header{display:flex;align-items:center;gap:12px;padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.02)}
    .brand{font-weight:700;letter-spacing:0.2px}
    .status{margin-left:auto;font-size:13px;color:var(--muted)}
    .main{flex:1;display:flex;flex-direction:column;padding:14px;gap:8px;overflow:hidden}
    .messages{flex:1;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
    .msg{padding:8px 10px;border-radius:8px;margin-bottom:8px;max-width:82%;word-wrap:break-word}
    .meta{font-size:12px;color:var(--muted);margin-bottom:6px}
    .msg .body{font-size:14px;color:#e6eef8}
    .msg.me{margin-left:auto;background:linear-gradient(90deg,#05201a,#063022);border:1px solid rgba(16,185,129,0.12)}
    .msg.other{background:linear-gradient(90deg,#08182a,#0b2740);border:1px solid rgba(96,165,250,0.06)}
    .composer{display:flex;flex-direction:column;border-top:1px solid rgba(255,255,255,0.02);gap:4px}
    .typing{font-size:13px;color:var(--muted);height:1em;padding-left:12px;transition:opacity .2s}
  /* nicer typing bubble with animated dots */
  .typing-bubble{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px}
  .typing-bubble .name{font-weight:600;color:var(--accent)}
  .typing-bubble .dots{display:inline-flex;gap:4px;width:24px;justify-content:center}
  .typing-bubble .dots i{display:inline-block;width:6px;height:6px;background:var(--muted);border-radius:50%;opacity:0.25;transform:translateY(0);animation:dot 1s infinite linear}
  .typing-bubble .dots i:nth-child(1){animation-delay:0s}
  .typing-bubble .dots i:nth-child(2){animation-delay:0.12s}
  .typing-bubble .dots i:nth-child(3){animation-delay:0.24s}
  @keyframes dot{0%{opacity:.25;transform:translateY(0)}50%{opacity:1;transform:translateY(-6px)}100%{opacity:.25;transform:translateY(0)}}
  /* embedded media styles */
  .embed{margin-top:8px;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.02);background:rgba(0,0,0,0.36)}
  .embed iframe{width:100%;aspect-ratio:16/9;height:auto;border:0;display:block}
  /* prevent horizontal scrolling caused by wide images/embeds */
  .messages{overflow-x:hidden}
  .msg .body img{max-width:100%;height:auto;display:block;margin-top:8px;border-radius:8px}
  /* custom scrollbar for messages */
  .messages::-webkit-scrollbar{width:10px;height:10px}
  .messages::-webkit-scrollbar-track{background:transparent;border-radius:10px}
  .messages::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.06);border-radius:10px}
  .messages::-webkit-scrollbar-thumb:hover{background:rgba(255,255,255,0.12)}
  /* firefox */
  .messages{scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.06) transparent}
  .image-preview{display:flex;align-items:flex-start;gap:8px;padding:8px 12px}
  .image-preview img{max-height:120px;border-radius:8px;box-shadow:0 4px 18px rgba(2,6,23,0.6)}
  .image-preview .remove{background:transparent;border:0;color:var(--muted);cursor:pointer;font-size:14px;padding:6px}
  .upload-progress{width:100%;padding:0 12px 8px}
  .upload-progress .bar{height:8px;background:linear-gradient(90deg,var(--accent),#7dd3fc);border-radius:999px;transition:width .2s;width:0}
    .composer-row{display:flex;align-items:center;gap:8px;padding:10px}
    input[type="text"].input{flex:1;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;outline:none}
    button{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:#071025;font-weight:600;cursor:pointer}
    footer.note{padding:10px 14px;border-top:1px solid rgba(255,255,255,0.01);font-size:12px;color:var(--muted)}
    .status-dot{display:inline-block;width:9px;height:9px;margin-right:8px;border-radius:50%;vertical-align:middle}
    .dot-green{background:var(--me)}
    .dot-red{background:#ef4444}
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="CloudLink chat client">
    <header>
      <div class="brand">Chat</div>
      <div class="small" style="margin-left:8px;color:var(--muted)">server: <code style="color:var(--accent)">tempo-cloudlink.loca.lt</code></div>
      <div class="status" id="status"><span id="statusDot" class="status-dot dot-red"></span><span id="statusText">disconnected</span></div>
    </header>

    <div class="main">
      <div class="messages" id="messages"></div>

      <div class="composer">
        <div class="typing" id="typingArea"></div>
        <!-- image preview appears here when a user pastes or selects an image -->
        <div id="imagePreview" class="image-preview" style="display:none"></div>
        <div id="uploadProgress" class="upload-progress" style="display:none">
          <div class="bar"></div>
        </div>
        <div class="composer-row">
          <input id="inputMessage" class="input" type="text" placeholder="Type a message..." autocomplete="off" />
          <input id="fileImage" type="file" accept="image/*" style="display:none" />
          <button id="btnImage" type="button">ðŸ“·</button>
          <button id="btnSend">Send</button>
        </div>
      </div>
    </div>

    <footer class="note">
      Basic CloudLink v4 chat (handshake â†’ direct(type=js) â†’ setid â†’ gmsg). Includes typing indicators.
    </footer>
  </div>

  <script>
  (function(){
    const WS_URL = 'wss://tempo-cloudlink.loca.lt';
  const messagesEl = document.getElementById('messages');
  const typingArea = document.getElementById('typingArea');
  const statusText = document.getElementById('statusText');
  const statusDot = document.getElementById('statusDot');
  const inputMessage = document.getElementById('inputMessage');
  const btnSend = document.getElementById('btnSend');
  const fileImage = document.getElementById('fileImage');
  const btnImage = document.getElementById('btnImage');
  const imagePreview = document.getElementById('imagePreview');
  const uploadProgress = document.getElementById('uploadProgress');
  const uploadBar = uploadProgress && uploadProgress.querySelector('.bar');

  // Replace this placeholder with your imgbb API key (you'll add it manually)
  const IMGBB_API_KEY = 'f014562f3e69dc9e97a2a1c812f54083';

  // Pending image state when a user pastes or selects an image
  let pendingImageDataUrl = null; // data:... string used for preview and upload
  let pendingImageFile = null; // File object (optional)

    let ws, username, connected=false;
    const typingUsers = new Map(); // {name: timeoutId}

    function askUsername() {
      const name = prompt('Enter your username:', '');
      if (!name || !name.trim()) return askUsername();
      username = name.trim();
    }
    askUsername();

    

    // Try to extract YouTube video ID from common URL forms
    function extractYouTubeID(url){
      try{
        const u = new URL(url);
        if(u.hostname.endsWith('youtube.com')){
          // watch?v=ID or /shorts/ID
          if(u.searchParams.get('v')) return u.searchParams.get('v');
          const p = u.pathname.split('/').filter(Boolean);
          // shorts/<id>
          if(p[0]==='shorts' && p[1]) return p[1];
        }
        if(u.hostname === 'youtu.be'){
          const id = u.pathname.split('/').filter(Boolean)[0];
          if(id) return id;
        }
      }catch(e){return null}
      return null;
    }

    // rudimentary image URL detection by extension
    function isImageUrl(url){
      try{ const u = new URL(url); return /\.(jpe?g|png|gif|webp|avif|bmp)$/i.test(u.pathname); }catch(e){return false}
    }

    // Convert plain text into DOM nodes: links become anchors, YouTube links become embedded iframes.
    // Also render direct image URLs as inline images.
    function parseMessageText(text){
      const frag = document.createDocumentFragment();
      if(!text) return frag;
      // Regex to match URLs starting with http(s) or www.
      const urlRegex = /((https?:\/\/|www\.)[^\s<>]+)/gi;
      let lastIndex = 0;
      let m;
      while((m = urlRegex.exec(text)) !== null){
        const url = m[0];
        const idx = m.index;
        if(idx > lastIndex){
          frag.appendChild(document.createTextNode(text.slice(lastIndex, idx)));
        }
        const normalized = url.startsWith('www.') ? 'http://' + url : url;
        // detect YouTube URLs and extract video id
        const ytId = extractYouTubeID(normalized);
        if(ytId){
          const a = document.createElement('a');
          a.href = normalized;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.textContent = url;
          frag.appendChild(a);
          const embed = document.createElement('div');
          embed.className = 'embed';
          const iframe = document.createElement('iframe');
          iframe.src = 'https://www.youtube.com/embed/' + ytId + '?rel=0';
          iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
          iframe.allowFullscreen = true;
          embed.appendChild(iframe);
          frag.appendChild(embed);
        } else if(isImageUrl(normalized)){
          // show image inline (wrapped in link)
          const a = document.createElement('a');
          a.href = normalized;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          const img = document.createElement('img');
          img.src = normalized;
          a.appendChild(img);
          frag.appendChild(a);
        } else {
          const a = document.createElement('a');
          a.href = normalized;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.textContent = url;
          frag.appendChild(a);
        }
        lastIndex = idx + url.length;
      }
      if(lastIndex < text.length){
        frag.appendChild(document.createTextNode(text.slice(lastIndex)));
      }
      return frag;
    }

    function addMessage({from, body, time, me=false}) {
      const wrap = document.createElement('div');
      wrap.className = 'msg ' + (me ? 'me' : 'other');
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = from + ' ';
      const tspan = document.createElement('span');
      tspan.className = 'time';
      tspan.textContent = new Date(time||Date.now()).toLocaleTimeString();
      meta.appendChild(tspan);
      const bodyEl = document.createElement('div');
      bodyEl.className = 'body';
      // parse and append nodes instead of raw HTML to avoid XSS
      bodyEl.appendChild(parseMessageText(String(body)));
      wrap.appendChild(meta);
      wrap.appendChild(bodyEl);
      messagesEl.appendChild(wrap);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // --- image selection / paste / upload logic ---
    function renderImagePreview(dataUrl){
      imagePreview.innerHTML = '';
      if(!dataUrl){ imagePreview.style.display='none'; return }
      const img = document.createElement('img');
      img.src = dataUrl;
      img.alt = 'preview';
      const rm = document.createElement('button');
      rm.className = 'remove';
      rm.title = 'Remove image';
      rm.textContent = 'âœ–';
      rm.addEventListener('click', ()=>{ clearImagePreview(); });
      imagePreview.appendChild(img);
      imagePreview.appendChild(rm);
      imagePreview.style.display='flex';
    }

    function clearImagePreview(){
      pendingImageDataUrl = null;
      pendingImageFile = null;
      try{ fileImage.value = ''; }catch(e){}
      imagePreview.innerHTML = '';
      imagePreview.style.display = 'none';
    }

    function dataURLFromFile(file){
      return new Promise((resolve,reject)=>{
        const fr = new FileReader();
        fr.onload = ()=>resolve(fr.result);
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    function uploadImageToImgbb(dataUrl){
      return new Promise((resolve,reject)=>{
        if(!IMGBB_API_KEY || IMGBB_API_KEY==='YOUR_IMGBB_API_KEY_HERE'){
          return reject(new Error('No imgbb API key provided. Please set IMGBB_API_KEY in the HTML.'));
        }
        try{
          const base64 = dataUrl.split(',')[1];
          const form = new FormData();
          form.append('key', IMGBB_API_KEY);
          form.append('image', base64);
          // show progress UI
          if(uploadProgress && uploadBar){ uploadProgress.style.display='block'; uploadBar.style.width='0%'; }
          const xhr = new XMLHttpRequest();
          xhr.open('POST','https://api.imgbb.com/1/upload');
          xhr.upload.onprogress = function(ev){
            if(ev.lengthComputable && uploadBar){
              const pct = Math.round((ev.loaded/ev.total)*100);
              uploadBar.style.width = pct + '%';
            }
          };
          xhr.onload = function(){
            try{
              const j = JSON.parse(xhr.responseText);
              if(xhr.status>=200 && xhr.status<300 && j && j.success){
                resolve(j.data.display_url || j.data.url);
              } else {
                reject(new Error((j && j.error && j.error.message) ? j.error.message : 'upload failed'));
              }
            }catch(err){ reject(err); }
          };
          xhr.onerror = function(){ reject(new Error('Network error during upload')); };
          xhr.onloadend = function(){ if(uploadProgress && uploadBar){ uploadBar.style.width='100%'; setTimeout(()=>{ if(uploadProgress) uploadProgress.style.display='none'; if(uploadBar) uploadBar.style.width='0%'; },600); } };
          xhr.send(form);
        }catch(err){ if(uploadProgress) uploadProgress.style.display='none'; reject(err); }
      });
    }

    function setStatus(text, ok=false){
      statusText.textContent=text;
      statusDot.className='status-dot '+(ok?'dot-green':'dot-red');
    }

    function cl(obj){return JSON.stringify(obj);}

    function updateTypingDisplay(){
      // render animated typing bubbles for each typing user
      typingArea.innerHTML = '';
      const names = Array.from(typingUsers.keys());
      if(names.length===0){
        return;
      }
      names.forEach(name=>{
        const bubble = document.createElement('span');
        bubble.className = 'typing-bubble';
        const nm = document.createElement('span');
        nm.className = 'name';
        nm.textContent = name; // safe: textContent escapes
        const dots = document.createElement('span');
        dots.className = 'dots';
        for(let i=0;i<3;i++){ const d = document.createElement('i'); dots.appendChild(d); }
        bubble.appendChild(nm);
        bubble.appendChild(dots);
        typingArea.appendChild(bubble);
      });
    }

    function showTyping(from){
      if(from===username) return;
      const prev = typingUsers.get(from);
      if(prev) clearTimeout(prev);
      const timeout = setTimeout(()=>{
        typingUsers.delete(from);
        updateTypingDisplay();
      },3000);
      typingUsers.set(from, timeout);
      updateTypingDisplay();
    }

    function connect(){
      setStatus('connecting...');
      ws = new WebSocket(WS_URL);
      ws.addEventListener('open',()=>{
        connected=true;
        setStatus('connected as '+username,true);
        ws.send(cl({cmd:'handshake'}));
        ws.send(cl({cmd:'direct',val:{cmd:'type',val:'js'}}));
        ws.send(cl({cmd:'setid',val:username}));
      });

      ws.addEventListener('message',ev=>{
        let p; try{p=JSON.parse(ev.data);}catch{return;}
        const {cmd,val}=p;
        if(cmd==='gmsg'&&val){
          const sender = val.from||p.name||'unknown';
          if(sender===username) return; // skip self echoes
          if(val.typing){ showTyping(sender); return; } // typing indicator
          const msg = val.msg||val.message||String(val);
          addMessage({from:sender,body:msg});
        }
      });

      ws.addEventListener('close',()=>{
        connected=false;
        setStatus('disconnected');
      });
    }

    function sendChat(text){
      if(!ws||ws.readyState!==WebSocket.OPEN)return;
      ws.send(cl({cmd:'gmsg',val:{from:username,msg:text}}));
      addMessage({from:username,body:text,me:true});
    }

    let typingTimeout=null, lastTypeTime=0;
    function sendTyping(){
      if(!ws||ws.readyState!==WebSocket.OPEN)return;
      const now=Date.now();
      if(now-lastTypeTime<800) return; // debounce ~0.8s
      lastTypeTime=now;
      ws.send(cl({cmd:'gmsg',val:{from:username,typing:true}}));
    }

    inputMessage.addEventListener('input',sendTyping);

    // handle paste of images into the input (or anywhere on the document)
    inputMessage.addEventListener('paste', async (e)=>{
      try{
        const items = (e.clipboardData && e.clipboardData.items) || [];
        for(const it of items){
          if(it.type && it.type.indexOf('image')===0){
            const file = it.getAsFile();
            if(file){
              pendingImageFile = file;
              const dataUrl = await dataURLFromFile(file);
              pendingImageDataUrl = dataUrl;
              renderImagePreview(dataUrl);
              break;
            }
          }
        }
      }catch(err){ console.warn('paste image failed',err); }
    });

    // file selection via button
    btnImage.addEventListener('click',()=> fileImage.click());
    fileImage.addEventListener('change', async ()=>{
      const f = fileImage.files && fileImage.files[0];
      if(!f) return;
      pendingImageFile = f;
      try{ pendingImageDataUrl = await dataURLFromFile(f); renderImagePreview(pendingImageDataUrl); }catch(e){ console.warn(e); }
    });

    btnSend.addEventListener('click', async ()=>{
      const text = inputMessage.value.trim();
      const hasImage = !!pendingImageDataUrl || !!pendingImageFile;
      if(!text && !hasImage) return;
      btnSend.disabled = true;
      btnImage.disabled = true;
      try{
        let uploadedUrl = null;
        if(hasImage){
          const dataUrl = pendingImageDataUrl || (pendingImageFile ? await dataURLFromFile(pendingImageFile) : null);
          if(dataUrl){
            uploadedUrl = await uploadImageToImgbb(dataUrl);
          }
        }
        // compose message: include text and image url if both present
        const payload = text && uploadedUrl ? text + '\n' + uploadedUrl : (uploadedUrl || text);
        if(payload) sendChat(payload);
        inputMessage.value='';
        clearImagePreview();
      }catch(err){
        alert('Failed to upload image: '+ (err && err.message ? err.message : String(err)));
      }finally{ btnSend.disabled = false; btnImage.disabled = false; if(uploadProgress) uploadProgress.style.display='none'; }
    });
    inputMessage.addEventListener('keydown',e=>{
      if(e.key==='Enter'){e.preventDefault();btnSend.click();}
    });

    connect();
  })();
  </script>
</body>
</html>
