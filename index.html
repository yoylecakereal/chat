<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat</title>
  <style>
    :root{--bg:#0f1720;--card:#111827;--muted:#9ca3af;--accent:#60a5fa;--me:#10b981}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#071025 0%, #0b1220 100%);color:#e6eef8;display:flex;align-items:center;justify-content:center;padding:18px}
    .app{width:100%;max-width:820px;height:90vh;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.7);display:flex;flex-direction:column;overflow:hidden}
    header{display:flex;align-items:center;gap:12px;padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.02)}
    .brand{font-weight:700;letter-spacing:0.2px}
    .status{margin-left:auto;font-size:13px;color:var(--muted)}
    .main{flex:1;display:flex;flex-direction:column;padding:14px;gap:8px;overflow:hidden}
  /* make .messages a column flex container so items size to content width */
  .messages{flex:1;display:flex;flex-direction:column;align-items:flex-start;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
  /* message bubbles now size to their contents up to max-width */
  .msg{display:inline-block;padding:8px 10px;border-radius:8px;margin-bottom:8px;max-width:72%;word-wrap:break-word;width:auto}
    .meta{font-size:12px;color:var(--muted);margin-bottom:6px}
    .msg .body{font-size:14px;color:#e6eef8}
  .msg.me{align-self:flex-end;background:linear-gradient(90deg,#05201a,#063022);border:1px solid rgba(16,185,129,0.12)}
  .msg.other{align-self:flex-start;background:linear-gradient(90deg,#08182a,#0b2740);border:1px solid rgba(96,165,250,0.06)}
    .composer{display:flex;flex-direction:column;border-top:1px solid rgba(255,255,255,0.02);gap:4px}
    .typing{font-size:13px;color:var(--muted);height:1em;padding-left:12px;transition:opacity .2s}
  /* nicer typing bubble with animated dots */
  .typing-bubble{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px}
  .typing-bubble .name{font-weight:600;color:var(--accent)}
  .typing-bubble .dots{display:inline-flex;gap:4px;width:24px;justify-content:center}
  .typing-bubble .dots i{display:inline-block;width:6px;height:6px;background:var(--muted);border-radius:50%;opacity:0.25;transform:translateY(0);animation:dot 1s infinite linear}
  .typing-bubble .dots i:nth-child(1){animation-delay:0s}
  .typing-bubble .dots i:nth-child(2){animation-delay:0.12s}
  .typing-bubble .dots i:nth-child(3){animation-delay:0.24s}
  @keyframes dot{0%{opacity:.25;transform:translateY(0)}50%{opacity:1;transform:translateY(-6px)}100%{opacity:.25;transform:translateY(0)}}
  /* embedded media styles */
  .embed{margin-top:8px;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.02);background:rgba(0,0,0,0.36)}
  .embed iframe{width:100%;aspect-ratio:16/9;height:auto;border:0;display:block}
  /* prevent horizontal scrolling caused by wide images/embeds */
  .messages{overflow-x:hidden}
  /* images render smaller and scale to their bubble (limited max width) */
  .msg .body img{max-width:360px;width:100%;height:auto;display:block;margin-top:8px;border-radius:8px}
  /* custom scrollbar for messages */
  .messages::-webkit-scrollbar{width:10px;height:10px}
  .messages::-webkit-scrollbar-track{background:transparent;border-radius:10px}
  .messages::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.06);border-radius:10px}
  .messages::-webkit-scrollbar-thumb:hover{background:rgba(255,255,255,0.12)}
  /* firefox */
  .messages{scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.06) transparent}
  .image-preview{display:flex;align-items:flex-start;gap:8px;padding:8px 12px}
  .image-preview img{max-height:120px;border-radius:8px;box-shadow:0 4px 18px rgba(2,6,23,0.6)}
  .image-preview .remove{background:transparent;border:0;color:var(--muted);cursor:pointer;font-size:14px;padding:6px}
  .image-preview audio{max-width:320px}
  .upload-progress{width:100%;padding:0 12px 8px}
  .upload-progress .bar{height:8px;background:linear-gradient(90deg,var(--accent),#7dd3fc);border-radius:999px;transition:width .2s;width:0}
  /* drag & drop overlay */
  .drop-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(6,8,15,0.6);backdrop-filter:blur(4px);color:#e6eef8;font-size:20px;z-index:60;pointer-events:none;opacity:0;transition:opacity .15s}
  .drop-overlay.active{pointer-events:auto;opacity:1}
    .composer-row{display:flex;align-items:center;gap:8px;padding:10px}
    input[type="text"].input{flex:1;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;outline:none}
    button{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:#071025;font-weight:600;cursor:pointer}
    footer.note{padding:10px 14px;border-top:1px solid rgba(255,255,255,0.01);font-size:12px;color:var(--muted)}
    .status-dot{display:inline-block;width:9px;height:9px;margin-right:8px;border-radius:50%;vertical-align:middle}
    .dot-green{background:var(--me)}
    .dot-red{background:#ef4444}
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="CloudLink chat client">
    <header>
      <div class="brand">Chat</div>
      <div class="small" style="margin-left:8px;color:var(--muted)">server: <code style="color:var(--accent)">tempo-cloudlink.loca.lt</code></div>
      <div class="status" id="status"><span id="statusDot" class="status-dot dot-red"></span><span id="statusText">disconnected</span></div>
    </header>

    <div class="main">
      <div class="messages" id="messages"></div>
      <div id="dropOverlay" class="drop-overlay">Drop images here to attach</div>

      <div class="composer">
        <div class="typing" id="typingArea"></div>
        <!-- image preview appears here when a user pastes or selects an image -->
        <div id="imagePreview" class="image-preview" style="display:none"></div>
        <div id="uploadProgress" class="upload-progress" style="display:none">
          <div class="bar"></div>
        </div>
        <div class="composer-row">
          <input id="inputMessage" class="input" type="text" placeholder="Type a message..." autocomplete="off" />
          <input id="fileImage" type="file" accept="image/*" style="display:none" />
          <input id="fileAudio" type="file" accept="audio/*" style="display:none" />
          <button id="btnAudio" type="button">ðŸŽµ</button>
          <button id="btnImage" type="button">ðŸ“·</button>
          <button id="btnSend">Send</button>
        </div>
      </div>
    </div>

    <footer class="note">
      Basic CloudLink v4 chat (handshake â†’ direct(type=js) â†’ setid â†’ gmsg). Includes typing indicators.
    </footer>
  </div>

  <script>
  (function(){
    const WS_URL = 'wss://tempo-cloudlink.loca.lt';
  const messagesEl = document.getElementById('messages');
  const typingArea = document.getElementById('typingArea');
  const statusText = document.getElementById('statusText');
  const statusDot = document.getElementById('statusDot');
  const inputMessage = document.getElementById('inputMessage');
  const btnSend = document.getElementById('btnSend');
  const fileImage = document.getElementById('fileImage');
  const fileAudio = document.getElementById('fileAudio');
  const btnImage = document.getElementById('btnImage');
  const btnAudio = document.getElementById('btnAudio');
  const imagePreview = document.getElementById('imagePreview');
  const uploadProgress = document.getElementById('uploadProgress');
  const uploadBar = uploadProgress && uploadProgress.querySelector('.bar');
  const dropOverlay = document.getElementById('dropOverlay');

  // Replace this placeholder with your imgbb API key (you'll add it manually)
  const IMGBB_API_KEY = 'f014562f3e69dc9e97a2a1c812f54083';

  // Pending image state when a user pastes or selects an image
  let pendingImageDataUrl = null; // data:... string used for preview and upload
  let pendingImageFile = null; // File object (optional)
  let pendingAudioFile = null;
  let previewObjectUrl = null;
  let currentUploadXhr = null; // allow canceling / tracking

    let ws, username, connected=false;
    const typingUsers = new Map(); // {name: timeoutId}

    function askUsername() {
      const name = prompt('Enter your username:', '');
      if (!name || !name.trim()) return askUsername();
      username = name.trim();
    }
    askUsername();

    

    // Try to extract YouTube video ID from common URL forms
    function extractYouTubeID(url){
      try{
        const u = new URL(url);
        if(u.hostname.endsWith('youtube.com')){
          // watch?v=ID or /shorts/ID
          if(u.searchParams.get('v')) return u.searchParams.get('v');
          const p = u.pathname.split('/').filter(Boolean);
          // shorts/<id>
          if(p[0]==='shorts' && p[1]) return p[1];
        }
        if(u.hostname === 'youtu.be'){
          const id = u.pathname.split('/').filter(Boolean)[0];
          if(id) return id;
        }
      }catch(e){return null}
      return null;
    }

    // rudimentary image URL detection by extension
    function isImageUrl(url){
      try{ const u = new URL(url); return /\.(jpe?g|png|gif|webp|avif|bmp)$/i.test(u.pathname); }catch(e){return false}
    }

    function isAudioUrl(url){
      try{ const u = new URL(url); return /\.(mp3|wav|ogg|m4a|flac|aac)$/i.test(u.pathname); }catch(e){return false}
    }

    // Convert plain text into DOM nodes: links become anchors, YouTube links become embedded iframes.
    // Also render direct image URLs as inline images.
    function parseMessageText(text){
      const frag = document.createDocumentFragment();
      if(!text) return frag;
      // Regex to match URLs starting with http(s) or www.
      const urlRegex = /((https?:\/\/|www\.)[^\s<>]+)/gi;
      let lastIndex = 0;
      let m;
      while((m = urlRegex.exec(text)) !== null){
        const url = m[0];
        const idx = m.index;
        if(idx > lastIndex){
          frag.appendChild(document.createTextNode(text.slice(lastIndex, idx)));
        }
        const normalized = url.startsWith('www.') ? 'http://' + url : url;
        // detect YouTube URLs and extract video id
        const ytId = extractYouTubeID(normalized);
        if(ytId){
          const a = document.createElement('a');
          a.href = normalized;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.textContent = url;
          frag.appendChild(a);
          const embed = document.createElement('div');
          embed.className = 'embed';
          const iframe = document.createElement('iframe');
          iframe.src = 'https://www.youtube.com/embed/' + ytId + '?rel=0';
          iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
          iframe.allowFullscreen = true;
          embed.appendChild(iframe);
          frag.appendChild(embed);
        } else if(isImageUrl(normalized)){
          // show image inline (wrapped in link)
          const a = document.createElement('a');
          a.href = normalized;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          const img = document.createElement('img');
          img.src = normalized;
          a.appendChild(img);
          frag.appendChild(a);
        } else if(isAudioUrl(normalized)){
          // show audio inline
          const div = document.createElement('div');
          const audio = document.createElement('audio'); audio.controls = true; audio.src = normalized; audio.style.maxWidth='320px';
          div.appendChild(audio); frag.appendChild(div);
        } else {
          const a = document.createElement('a');
          a.href = normalized;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.textContent = url;
          frag.appendChild(a);
        }
        lastIndex = idx + url.length;
      }
      if(lastIndex < text.length){
        frag.appendChild(document.createTextNode(text.slice(lastIndex)));
      }
      return frag;
    }

    function addMessage({from, body, time, me=false}) {
      const wrap = document.createElement('div');
      wrap.className = 'msg ' + (me ? 'me' : 'other');
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = from + ' ';
      const tspan = document.createElement('span');
      tspan.className = 'time';
      tspan.textContent = new Date(time||Date.now()).toLocaleTimeString();
      meta.appendChild(tspan);
      const bodyEl = document.createElement('div');
      bodyEl.className = 'body';
      // parse and append nodes instead of raw HTML to avoid XSS
      bodyEl.appendChild(parseMessageText(String(body)));
      wrap.appendChild(meta);
      wrap.appendChild(bodyEl);
      messagesEl.appendChild(wrap);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // --- image selection / paste / upload logic ---
    function renderImagePreview(dataUrl){
      imagePreview.innerHTML = '';
      if(!dataUrl){ imagePreview.style.display='none'; return }
      const img = document.createElement('img');
      img.src = dataUrl;
      img.alt = 'preview';
      const rm = document.createElement('button');
      rm.className = 'remove';
      rm.title = 'Remove media';
      rm.textContent = 'âœ–';
      rm.addEventListener('click', ()=>{ clearImagePreview(); });
      imagePreview.appendChild(img);
      imagePreview.appendChild(rm);
      imagePreview.style.display='flex';
    }

    function clearImagePreview(){
      pendingImageDataUrl = null;
      pendingImageFile = null;
      pendingAudioFile = null;
      if(previewObjectUrl){ try{ URL.revokeObjectURL(previewObjectUrl); }catch(e){} previewObjectUrl = null; }
      try{ fileImage.value = ''; }catch(e){}
      try{ fileAudio.value = ''; }catch(e){}
      imagePreview.innerHTML = '';
      imagePreview.style.display = 'none';
    }

    function dataURLFromFile(file){
      return new Promise((resolve,reject)=>{
        const fr = new FileReader();
        fr.onload = ()=>resolve(fr.result);
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    function uploadImageToImgbb(dataUrl){
      return new Promise((resolve,reject)=>{
        if(!IMGBB_API_KEY || IMGBB_API_KEY==='YOUR_IMGBB_API_KEY_HERE'){
          return reject(new Error('No imgbb API key provided. Please set IMGBB_API_KEY in the HTML.'));
        }
        try{
          const base64 = dataUrl.split(',')[1];
          const form = new FormData();
          form.append('key', IMGBB_API_KEY);
          form.append('image', base64);
          // show progress UI
          if(uploadProgress && uploadBar){ uploadProgress.style.display='block'; uploadBar.style.width='0%'; }
          const xhr = new XMLHttpRequest();
          currentUploadXhr = xhr;
          xhr.open('POST','https://api.imgbb.com/1/upload');
          xhr.upload.onprogress = function(ev){
            if(ev.lengthComputable && uploadBar){
              const pct = Math.round((ev.loaded/ev.total)*100);
              uploadBar.style.width = pct + '%';
            }
          };
          xhr.onload = function(){
            try{
              const j = JSON.parse(xhr.responseText);
              if(xhr.status>=200 && xhr.status<300 && j && j.success){
                currentUploadXhr = null;
                resolve(j.data.display_url || j.data.url);
              } else {
                currentUploadXhr = null;
                reject(new Error((j && j.error && j.error.message) ? j.error.message : 'upload failed'));
              }
            }catch(err){ reject(err); }
          };
          xhr.onerror = function(){ reject(new Error('Network error during upload')); };
          xhr.onloadend = function(){ if(uploadProgress && uploadBar){ uploadBar.style.width='100%'; setTimeout(()=>{ if(uploadProgress) uploadProgress.style.display='none'; if(uploadBar) uploadBar.style.width='0%'; },600); } currentUploadXhr = null; };
          xhr.send(form);
        }catch(err){ if(uploadProgress) uploadProgress.style.display='none'; reject(err); }
      });
    }

    // Cancel current upload (if any)
    function cancelCurrentUpload(){ if(currentUploadXhr){ try{ currentUploadXhr.abort(); }catch(e){} currentUploadXhr = null; if(uploadProgress) uploadProgress.style.display='none'; } }

    // Resize image dataURL to a maximum dimension (keeping aspect ratio).
    function resizeDataUrl(dataUrl, maxDim){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = function(){
          let w = img.naturalWidth, h = img.naturalHeight;
          if(w <= maxDim && h <= maxDim) return resolve(dataUrl);
          const ratio = w/h;
          if(w > h){ w = maxDim; h = Math.round(maxDim/ratio); } else { h = maxDim; w = Math.round(maxDim*ratio); }
          const canvas = document.createElement('canvas');
          canvas.width = w; canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img,0,0,w,h);
          // use jpeg to reduce size; keep quality 0.85
          try{ const out = canvas.toDataURL('image/jpeg',0.85); resolve(out); }catch(e){ try{ resolve(canvas.toDataURL()); }catch(ex){ reject(ex); } }
        };
        img.onerror = reject;
        img.src = dataUrl;
      });
    }

    // upload audio file to a simple file host (file.io) - returns URL
    function uploadAudioToFile(file){
      return new Promise((resolve,reject)=>{
        if(!file) return reject(new Error('no file'));
        try{
          if(uploadProgress && uploadBar){ uploadProgress.style.display='block'; uploadBar.style.width='0%'; }
          const xhr = new XMLHttpRequest();
          currentUploadXhr = xhr;
          const form = new FormData();
          form.append('file', file);
          // file.io endpoint
          xhr.open('POST','https://file.io/?expires=14d');
          xhr.upload.onprogress = function(ev){ if(ev.lengthComputable && uploadBar){ const pct = Math.round((ev.loaded/ev.total)*100); uploadBar.style.width = pct + '%'; } };
          xhr.onload = function(){
            try{
              const j = JSON.parse(xhr.responseText);
              if(xhr.status>=200 && xhr.status<300 && j && j.success && j.link){ currentUploadXhr = null; resolve(j.link); }
              else { currentUploadXhr = null; reject(new Error('upload failed')); }
            }catch(err){ currentUploadXhr = null; reject(err); }
          };
          xhr.onerror = function(){ currentUploadXhr = null; reject(new Error('Network error during upload')); };
          xhr.onloadend = function(){ if(uploadProgress && uploadBar){ uploadBar.style.width='100%'; setTimeout(()=>{ if(uploadProgress) uploadProgress.style.display='none'; if(uploadBar) uploadBar.style.width='0%'; },600); } currentUploadXhr = null; };
          xhr.send(form);
        }catch(err){ if(uploadProgress) uploadProgress.style.display='none'; reject(err); }
      });
    }

    // Resize File -> dataURL
    async function resizeFileToDataUrl(file, maxDim){
      const dataUrl = await dataURLFromFile(file);
      return resizeDataUrl(dataUrl, maxDim);
    }

    // Ensure websocket is connected; try to connect and wait up to timeoutMs
    function ensureConnected(timeoutMs = 5000){
      return new Promise((resolve,reject)=>{
        if(ws && ws.readyState === WebSocket.OPEN) return resolve(true);
        let settled = false;
        const onOpen = ()=>{ if(settled) return; settled = true; resolve(true); };
        const onClose = ()=>{ /* keep waiting until timeout */ };
        const timer = setTimeout(()=>{ if(settled) return; settled = true; try{ ws && ws.removeEventListener('open', onOpen); ws && ws.removeEventListener('close', onClose); }catch(e){} reject(new Error('connect timeout')); }, timeoutMs);
        try{
          if(!ws || ws.readyState === WebSocket.CLOSED){ connect(); }
          if(ws.readyState === WebSocket.OPEN){ clearTimeout(timer); settled = true; resolve(true); return; }
          ws.addEventListener('open', onOpen);
          ws.addEventListener('close', onClose);
        }catch(err){ clearTimeout(timer); reject(err); }
      });
    }

    function setStatus(text, ok=false){
      statusText.textContent=text;
      statusDot.className='status-dot '+(ok?'dot-green':'dot-red');
    }

    function cl(obj){return JSON.stringify(obj);}

    function updateTypingDisplay(){
      // render animated typing bubbles for each typing user
      typingArea.innerHTML = '';
      const names = Array.from(typingUsers.keys());
      if(names.length===0){
        return;
      }
      names.forEach(name=>{
        const bubble = document.createElement('span');
        bubble.className = 'typing-bubble';
        const nm = document.createElement('span');
        nm.className = 'name';
        nm.textContent = name; // safe: textContent escapes
        const dots = document.createElement('span');
        dots.className = 'dots';
        for(let i=0;i<3;i++){ const d = document.createElement('i'); dots.appendChild(d); }
        bubble.appendChild(nm);
        bubble.appendChild(dots);
        typingArea.appendChild(bubble);
      });
    }

    function showTyping(from){
      if(from===username) return;
      const prev = typingUsers.get(from);
      if(prev) clearTimeout(prev);
      const timeout = setTimeout(()=>{
        typingUsers.delete(from);
        updateTypingDisplay();
      },3000);
      typingUsers.set(from, timeout);
      updateTypingDisplay();
    }

    function connect(){
      setStatus('connecting...');
      ws = new WebSocket(WS_URL);
      ws.addEventListener('open',()=>{
        connected=true;
        setStatus('connected as '+username,true);
        ws.send(cl({cmd:'handshake'}));
        ws.send(cl({cmd:'direct',val:{cmd:'type',val:'js'}}));
        ws.send(cl({cmd:'setid',val:username}));
      });

      ws.addEventListener('message',ev=>{
        let p; try{p=JSON.parse(ev.data);}catch{return;}
        const {cmd,val}=p;
        if(cmd==='gmsg'&&val){
          const sender = val.from||p.name||'unknown';
          if(sender===username) return; // skip self echoes
          if(val.typing){ showTyping(sender); return; } // typing indicator
          const msg = val.msg||val.message||String(val);
          addMessage({from:sender,body:msg});
        }
      });

      ws.addEventListener('close',()=>{
        connected=false;
        setStatus('disconnected');
      });
    }

    function sendChat(text){
      if(!ws||ws.readyState!==WebSocket.OPEN)return;
      ws.send(cl({cmd:'gmsg',val:{from:username,msg:text}}));
      addMessage({from:username,body:text,me:true});
    }

    let typingTimeout=null, lastTypeTime=0;
    function sendTyping(){
      if(!ws||ws.readyState!==WebSocket.OPEN)return;
      const now=Date.now();
      if(now-lastTypeTime<800) return; // debounce ~0.8s
      lastTypeTime=now;
      ws.send(cl({cmd:'gmsg',val:{from:username,typing:true}}));
    }

    inputMessage.addEventListener('input',sendTyping);

    // handle paste of images into the input (or anywhere on the document)
    inputMessage.addEventListener('paste', async (e)=>{
      try{
        const items = (e.clipboardData && e.clipboardData.items) || [];
        for(const it of items){
          if(it.type && it.type.indexOf('image')===0){
            const file = it.getAsFile();
            if(file){
              pendingImageFile = file;
              // resize pasted image to a reasonable max dimension
              try{
                const resized = await resizeFileToDataUrl(file, 1024);
                pendingImageDataUrl = resized;
                pendingImageFile = null; // use dataUrl for upload
                renderImagePreview(resized);
              }catch(e){
                const dataUrl = await dataURLFromFile(file);
                pendingImageDataUrl = dataUrl;
                renderImagePreview(dataUrl);
              }
              break;
            }
          }
        }
      }catch(err){ console.warn('paste image failed',err); }
    });

  // file selection via button
  btnImage.addEventListener('click',()=> fileImage.click());
    fileImage.addEventListener('change', async ()=>{
      const f = fileImage.files && fileImage.files[0];
      if(!f) return;
      // resize selected file before preview/upload
      try{
        const resized = await resizeFileToDataUrl(f, 1024);
        pendingImageDataUrl = resized;
        pendingImageFile = null; // clear original to avoid double work
        renderImagePreview(resized);
      }catch(e){
        pendingImageFile = f;
        try{ pendingImageDataUrl = await dataURLFromFile(f); renderImagePreview(pendingImageDataUrl); }catch(ex){ console.warn(ex); }
      }
    });
    // audio file selected
    fileAudio.addEventListener('change', async ()=>{
      const f = fileAudio.files && fileAudio.files[0];
      if(!f) return;
      if(!f.type || f.type.indexOf('audio')!==0) return;
      pendingAudioFile = f;
      // preview audio via object URL
      imagePreview.innerHTML = '';
      const audio = document.createElement('audio');
      audio.controls = true;
      if(previewObjectUrl){ try{ URL.revokeObjectURL(previewObjectUrl); }catch(e){} previewObjectUrl = null; }
      previewObjectUrl = URL.createObjectURL(f);
      audio.src = previewObjectUrl;
      const rm = document.createElement('button'); rm.className='remove'; rm.textContent='âœ–'; rm.addEventListener('click',()=>{ clearImagePreview(); });
      imagePreview.appendChild(audio); imagePreview.appendChild(rm); imagePreview.style.display='flex';
    });
  // audio button
  btnAudio.addEventListener('click', ()=> fileAudio.click());

    // drag & drop handling (document-level)
    function showDropOverlay(show){ if(dropOverlay) dropOverlay.classList.toggle('active', !!show); }
    document.addEventListener('dragenter',(e)=>{ e.preventDefault(); showDropOverlay(true); },{passive:false});
    document.addEventListener('dragover',(e)=>{ e.preventDefault(); showDropOverlay(true); },{passive:false});
    document.addEventListener('dragleave',(e)=>{ e.preventDefault(); /* only hide when leaving window */ if(e.relatedTarget==null) showDropOverlay(false); },{passive:false});
    document.addEventListener('drop', async (e)=>{
      e.preventDefault(); showDropOverlay(false);
      const files = (e.dataTransfer && e.dataTransfer.files) || [];
      if(!files || files.length===0) return;
      // try to find an image first
      let handled = false;
      for(const f of files){
        if(f.type && f.type.indexOf('image')===0){
          try{
            const resized = await resizeFileToDataUrl(f, 1024);
            pendingImageDataUrl = resized; pendingImageFile = null; renderImagePreview(resized);
          }catch(err){
            try{ pendingImageFile = f; pendingImageDataUrl = await dataURLFromFile(f); renderImagePreview(pendingImageDataUrl); }catch(e){console.warn(e);} 
          }
          handled = true; break;
        }
      }
      if(handled) return;
      // otherwise look for audio
      for(const f of files){
        if(f.type && f.type.indexOf('audio')===0){
          pendingAudioFile = f;
          imagePreview.innerHTML = '';
          const audio = document.createElement('audio'); audio.controls=true; if(previewObjectUrl){ try{ URL.revokeObjectURL(previewObjectUrl); }catch(e){} previewObjectUrl=null;} previewObjectUrl = URL.createObjectURL(f); audio.src = previewObjectUrl;
          const rm = document.createElement('button'); rm.className='remove'; rm.textContent='âœ–'; rm.addEventListener('click',()=>{ clearImagePreview(); });
          imagePreview.appendChild(audio); imagePreview.appendChild(rm); imagePreview.style.display='flex';
          break;
        }
      }
    },{passive:false});

    btnSend.addEventListener('click', async ()=>{
      const text = inputMessage.value.trim();
      const hasImage = !!pendingImageDataUrl || !!pendingImageFile;
      const hasAudio = !!pendingAudioFile;
      if(!text && !hasImage && !hasAudio) return;
      btnSend.disabled = true;
      btnImage.disabled = true;
      btnAudio.disabled = true;
      try{
        let uploadedUrl = null;
        if(hasImage){
          // get resized data url if we have a file or dataUrl (pendingImageDataUrl already may be resized)
          const dataUrl = pendingImageDataUrl || (pendingImageFile ? await resizeFileToDataUrl(pendingImageFile, 1024) : null);
          if(dataUrl){
            uploadedUrl = await uploadImageToImgbb(dataUrl);
          }
        } else if(hasAudio){
          // upload audio file
          uploadedUrl = await uploadAudioToFile(pendingAudioFile);
        }
        // compose message: include text and media url if both present
        const payload = text && uploadedUrl ? text + '\n' + uploadedUrl : (uploadedUrl || text);
        if(payload){
          try{
            // attempt reconnect if needed
            if(!ws || ws.readyState !== WebSocket.OPEN){
              try{ await ensureConnected(5000); }catch(e){ /* couldn't reconnect in time */ }
            }
            sendChat(payload);
          }catch(e){
            // fallback: show locally
            addMessage({from:username,body:payload,me:true});
          }
        }
        inputMessage.value='';
        clearImagePreview();
      }catch(err){
        alert('Failed to upload media: '+ (err && err.message ? err.message : String(err)));
      }finally{ btnSend.disabled = false; btnImage.disabled = false; btnAudio.disabled = false; if(uploadProgress) uploadProgress.style.display='none'; }
    });
    inputMessage.addEventListener('keydown',e=>{
      if(e.key==='Enter'){e.preventDefault();btnSend.click();}
    });

    connect();
  })();
  </script>
</body>
</html>
